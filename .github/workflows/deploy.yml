name: Deploy to GKE

on:
  push:
    branches: ["main"]

permissions:
  contents: read
  id-token: write    # Required for Workload Identity Federation

jobs:
  # Wait for existing CI to pass first
  ci:
    uses: ./.github/workflows/go.yml

  deploy:
    name: Build & Deploy
    needs: ci
    runs-on: ubuntu-latest
    env:
      REGION: europe-west3
      CLUSTER: clouddns-cluster
      ZONE: europe-west3-a
      IMAGE: europe-west3-docker.pkg.dev/thecloud-clouddns/clouddns/clouddns

    steps:
      - uses: actions/checkout@v4

      # Keyless auth via Workload Identity Federation
      - id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - uses: google-github-actions/setup-gcloud@v2

      # Configure Docker to push to Artifact Registry
      - run: gcloud auth configure-docker europe-west3-docker.pkg.dev --quiet

      # Build and push with commit SHA tag
      - name: Build & Push
        run: |
          docker build --platform linux/amd64 \
            -t "$IMAGE:${{ github.sha }}" \
            -t "$IMAGE:latest" .
          docker push "$IMAGE:${{ github.sha }}"
          docker push "$IMAGE:latest"

      # Connect to GKE
      - uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.CLUSTER }}
          location: ${{ env.ZONE }}

      # Inject secrets from GCP Secret Manager into K8s
      - name: Inject Secrets
        run: |
          DB_URL=$(gcloud secrets versions access latest \
            --secret=clouddns-database-url --project=${{ secrets.GCP_PROJECT_ID }})
          kubectl create secret generic clouddns-secrets \
            --from-literal=database-url="$DB_URL" \
            --dry-run=client -o yaml | kubectl apply -f -

      # Deploy with the exact commit SHA (to ensure traceability)
      - name: Deploy
        run: |
          # Apply manifest to update resource requests/limits and other config
          kubectl apply -f infra/k8s/deployment.yaml
          
          # Set the new image
          kubectl set image deployment/clouddns \
            clouddns="$IMAGE:${{ github.sha }}"
          
          if ! kubectl rollout status deployment/clouddns --timeout=300s; then
            echo "❌ Deployment failed! Gathering debug info..."
            kubectl get nodes
            kubectl describe nodes
            kubectl get pods -l app=clouddns
            kubectl describe pods -l app=clouddns
            kubectl logs -l app=clouddns --tail=100
            exit 1
          fi

  smoke-test:
    name: Verify Deployment
    needs: deploy
    runs-on: ubuntu-latest
    env:
      CLUSTER: clouddns-cluster
      ZONE: europe-west3-a
    steps:
      - uses: actions/checkout@v4

      # auth
      - id: auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WIF_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT }}

      - uses: google-github-actions/setup-gcloud@v2

      # Connect to GKE
      - uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.CLUSTER }}
          location: ${{ env.ZONE }}

      # Smoke test: HTTP Health Check
      - name: Verify Health
        run: |
          echo "Waiting for LoadBalancer IP and health check..."
          for i in {1..20}; do
            EXTERNAL_IP=$(kubectl get svc clouddns-lb-tcp -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
            if [ -n "$EXTERNAL_IP" ]; then
              echo "Checking http://$EXTERNAL_IP:8080/health (attempt $i)"
              if curl -sf --max-time 5 "http://$EXTERNAL_IP:8080/health" | grep -q '"status":"UP"'; then
                echo "✅ Health check passed!"
                exit 0
              fi
            fi
            echo "Retrying in 10s..."
            sleep 10
          done
          echo "❌ Health check failed after 20 attempts"
          exit 1

      # DNS Verification: Live recursive lookups
      - name: DNS Smoke Test
        run: |
          DNS_IP=$(kubectl get svc clouddns-lb-udp -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Testing DNS resolution at $DNS_IP..."
          
          echo "--- Testing google.com ---"
          DIG_OUT=$(dig @$DNS_IP google.com +short +timeout=5 +tries=2)
          if [[ -z "$DIG_OUT" ]]; then
            echo "❌ Failed to resolve google.com"
            exit 1
          fi
          echo "Result: $DIG_OUT"
          
          echo "--- Testing example.com ---"
          DIG_OUT=$(dig @$DNS_IP example.com +short +timeout=5 +tries=2)
          if [[ -z "$DIG_OUT" ]]; then
            echo "❌ Failed to resolve example.com"
            exit 1
          fi
          echo "Result: $DIG_OUT"
          
          echo "✅ DNS Smoke Test Passed!"
